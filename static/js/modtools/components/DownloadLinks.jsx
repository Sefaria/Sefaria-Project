/**
 * DownloadLinks - Download links between refs as CSV
 *
 * Options:
 * - Ref 1 (required): Starting reference
 * - Ref 2 (optional): Target reference or "all" for entire library
 * - Type filter: Commentary, Quotation, etc.
 * - Generated by filter: Filter by who created the links
 * - Iterate by segments: Include empty segments in output
 *
 * Backend endpoint: GET /modtools/links/{ref1}/{ref2}
 */
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import qs from 'qs';
import Sefaria from '../../sefaria/sefaria';
import ModToolsSection from './shared/ModToolsSection';

/**
 * Help content for DownloadLinks
 */
const HELP_CONTENT = (
  <>
    <h3>What This Tool Does</h3>
    <p>
      This tool <strong>exports links as a CSV file</strong> for analysis or backup.
      You can download all connections from a specific text, or filter by type and source.
    </p>

    <h3>How It Works</h3>
    <ol>
      <li><strong>Enter Ref 1:</strong> The primary reference to get links from (required).</li>
      <li><strong>Enter Ref 2:</strong> Optional second reference to find links between two texts.</li>
      <li><strong>Apply filters:</strong> Optionally filter by link type or generator.</li>
      <li><strong>Download:</strong> Get a CSV file with all matching links.</li>
    </ol>

    <h3>Reference Fields</h3>
    <table className="field-table">
      <thead>
        <tr><th>Field</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Ref 1</strong></td>
          <td>
            Required. The text reference to get links from. Can be broad ("Genesis")
            or specific ("Genesis 1:1").
          </td>
        </tr>
        <tr>
          <td><strong>Ref 2</strong></td>
          <td>
            Optional. If blank, downloads links to the entire library (limited to 15k).
            If specified, downloads only links between Ref 1 and Ref 2.
          </td>
        </tr>
      </tbody>
    </table>

    <h3>Filter Options</h3>
    <table className="field-table">
      <thead>
        <tr><th>Filter</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Type</strong></td>
          <td>
            Filter by link type: Commentary, Quotation, Related, etc.
            Leave blank for all types.
          </td>
        </tr>
        <tr>
          <td><strong>Generated by</strong></td>
          <td>
            Filter by who/what created the link. Examples: "add_links_from_text",
            "auto-linker", or a username. Leave blank for all sources.
          </td>
        </tr>
        <tr>
          <td><strong>Iterate by segments</strong></td>
          <td>
            When checked, the output includes every segment in Ref 1, even if it
            has no links. Useful for finding gaps in link coverage.
          </td>
        </tr>
      </tbody>
    </table>

    <h3>Output Format</h3>
    <p>
      The downloaded CSV contains columns for source ref, target ref, link type,
      and other metadata. This format can be used with the Upload Links or Remove Links tools.
    </p>

    <div className="warning">
      <strong>Important Notes:</strong>
      <ul>
        <li>Results are <strong>limited to 15,000 links</strong> when Ref 2 is blank.</li>
        <li>Both refs are validated - red highlight indicates invalid reference.</li>
        <li>The Download button only becomes active when Ref 1 is valid.</li>
        <li>Large exports may take a moment to generate.</li>
      </ul>
    </div>

    <h3>Common Use Cases</h3>
    <ul>
      <li>Auditing existing links for a text before making changes</li>
      <li>Backing up links before bulk deletion</li>
      <li>Analyzing link coverage and finding gaps</li>
      <li>Exporting links for external analysis or documentation</li>
      <li>Getting exact ref formats for use with Remove Links tool</li>
    </ul>

    <h3>Troubleshooting</h3>
    <ul>
      <li><strong>Red input field</strong> - Reference is invalid. Check spelling and format.</li>
      <li><strong>Empty CSV</strong> - No links exist matching your criteria.</li>
      <li><strong>Download button disabled</strong> - Ref 1 must be entered and valid.</li>
      <li><strong>Missing links</strong> - Check type/generator filters aren't too restrictive.</li>
    </ul>
  </>
);

/**
 * Reference input field with validation
 */
const InputRef = ({ id, value, handleChange, handleBlur, error }) => (
  <label>
    Ref{id}
    <input
      type="text"
      name={`ref${id}`}
      value={value}
      onChange={handleChange}
      onBlur={handleBlur}
      style={error ? { backgroundColor: "rgba(255, 0, 0, 0.5)" } : {}}
      placeholder={id === 2 ? 'all library, limited to 15k links' : null}
    />
    <p role="alert" style={{ color: "rgb(255, 0, 0)" }}>{(error) ? "Not a valid ref" : ""}</p>
  </label>
);

InputRef.propTypes = {
  id: PropTypes.number.isRequired,
  value: PropTypes.string.isRequired,
  handleChange: PropTypes.func.isRequired,
  handleBlur: PropTypes.func.isRequired,
  error: PropTypes.bool,
};

/**
 * Generic text input field
 */
const InputNonRef = ({ name, value, handleChange }) => (
  <label>
    {name.charAt(0).toUpperCase() + name.slice(1)}
    <input
      type="text"
      name={name}
      value={value}
      onChange={handleChange}
      placeholder="any"
    />
  </label>
);

InputNonRef.propTypes = {
  name: PropTypes.string.isRequired,
  value: PropTypes.string.isRequired,
  handleChange: PropTypes.func.isRequired,
};

/**
 * Download button component
 */
const DownloadButton = () => (
  <div className="modtoolsButton">
    <div className="modtoolsButtonInner">
      Download
    </div>
  </div>
);

/**
 * Main DownloadLinks component
 */
function DownloadLinks() {
  const [refs, setRefs] = useState({ ref1: '', ref2: '' });
  const [errors, setErrors] = useState({ ref2: false });
  const [type, setType] = useState('');
  const [generatedBy, setGeneratedBy] = useState('');
  const [bySegment, setBySegment] = useState(false);

  const handleCheck = () => {
    setBySegment(!bySegment);
  };

  const handleChange = async (event) => {
    const { name, value } = event.target;
    setRefs(prev => ({ ...prev, [name]: value }));
    if (errors[name]) {
      if (!value) {
        setErrors(prev => ({ ...prev, [name]: false }));
      } else {
        try {
          const response = await Sefaria.getName(value);
          setErrors(prev => ({ ...prev, [name]: !response.is_ref }));
        } catch (error) {
          console.error(error);
        }
      }
    }
  };

  const handleBlur = async (event) => {
    const name = event.target.name;
    if (refs[name]) {
      try {
        const response = await Sefaria.getName(refs[name]);
        setErrors(prev => ({ ...prev, [name]: !response.is_ref }));
      } catch (error) {
        console.error(error);
      }
    }
  };

  const formReady = () => {
    return refs.ref1 && errors.ref1 === false && errors.ref2 === false;
  };

  const linksDownloadLink = () => {
    const queryParams = qs.stringify(
      { type: (type) ? type : null, generated_by: (generatedBy) ? generatedBy : null },
      { addQueryPrefix: true, skipNulls: true }
    );
    const tool = (bySegment) ? 'index_links' : 'links';
    return `modtools/${tool}/${refs.ref1}/${refs.ref2 || 'all'}${queryParams}`;
  };

  return (
    <ModToolsSection
      title="Download Links"
      titleHe="הורדת קישורים"
      helpContent={HELP_CONTENT}
    >
      <div className="getLinks">
        <form id="download-links-form">
          <fieldset>
            <InputRef id={1} value={refs.ref1} handleChange={handleChange} handleBlur={handleBlur} error={errors.ref1} />
            <label>
              <input
                type="checkbox"
                checked={bySegment}
                onChange={handleCheck}
              />
              iterate by segments (include empties)
            </label>
          </fieldset>
          <br />
          <InputRef id={2} value={refs.ref2} handleChange={handleChange} handleBlur={handleBlur} error={errors.ref2} />
          <br />
          <InputNonRef name='type' value={type} handleChange={(e) => setType(e.target.value)} />
          <br />
          <InputNonRef name='generated_by' value={generatedBy} handleChange={(e) => setGeneratedBy(e.target.value)} />
        </form>
        {formReady() ? <a href={linksDownloadLink()} download><DownloadButton /></a> : <DownloadButton />}
      </div>
    </ModToolsSection>
  );
}

export default DownloadLinks;
