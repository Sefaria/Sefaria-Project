{{- if and .Values.restore.enabled .Values.cronJobs.syncPostgresProductionData.enabled }}
# Safety check: Only create cronjob if restore is enabled (indicating dedicated DB)
#
# Required GCS Permissions for serviceAccount:
# - storage.objects.list (to list backup files and find the latest)
# - storage.objects.get (to download the backup file)
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ .Values.deployEnv }}-sync-postgres-production-data
  labels:
    {{- include "sefaria.labels" . | nindent 4 }}
spec:
  schedule: "0 2 * * 0"  # Every week on Sunday at 2 AM
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      backoffLimit: 1
      template:
        spec:
          serviceAccount: {{ .Values.backup.postgres.serviceAccount }}
          volumes:
            - name: shared-volume
              emptyDir: {}
          initContainers:
            - name: postgres-backup-downloader
              image: google/cloud-sdk
              volumeMounts:
                - name: shared-volume
                  mountPath: /storage
              command: ["bash"]
              args:
                - -c
                - |
                  set -e
                  echo "Finding latest PostgreSQL backup from production..."
                  
                  # List all postgres backup files and find the latest one by timestamp
                  echo "Listing available backups..."
                  # Use GCS timestamps for reliable sorting (column 2 is the timestamp)
                  latest_backup=$(gsutil ls -l gs://sefaria-user-backup/ | \
                    grep 'postgres_.*\.dump' | \
                    sort -k2 | \
                    tail -1 | \
                    awk '{print $3}')
                  
                  if [ -z "$latest_backup" ]; then
                    echo "ERROR: No PostgreSQL backup files found in bucket"
                    exit 1
                  fi
                  
                  echo "Found latest backup: $latest_backup"
                  echo "Downloading backup..."
                  gsutil cp "$latest_backup" /storage/pg.dump
                  
                  echo "Latest backup downloaded successfully"
          containers:
            - name: sync-postgres-production-data
              image: postgres:{{ .Values.backup.postgres.version }}
              volumeMounts:
                - name: shared-volume
                  mountPath: /storage
              command: ["/bin/bash"]
              args:
                - -c
                - |
                  set -e
                  echo "Starting sync of production PostgreSQL data to {{ .Values.deployEnv }}..."
                  
                  # Use the backup file downloaded by the init container
                  echo "Using backup file downloaded by init container: /storage/pg.dump"

                  # Set PostgreSQL connection environment variables
                  export PGHOST="{{ if .Values.postgres.host }}{{ .Values.postgres.host }}{{ else }}${DATABASES_HOST}{{ end }}"
                  export PGUSER="${DATABASES_USER}"
                  export PGPASSWORD="${DATABASES_PASSWORD}"
                  export PGDATABASE="{{ .Values.postgres.db }}"

                  echo "Restoring to database: $PGDATABASE"
                  echo "Using PostgreSQL host: $PGHOST"

                  # Ensure database exists (create if not exists)
                  echo "Ensuring database exists..."
                  psql -h "$PGHOST" -U "$PGUSER" -d postgres -c "CREATE DATABASE \"$PGDATABASE\";" 2>/dev/null || echo "Database already exists"

                  # Perform the restore with --clean to update existing tables
                  echo "Restoring PostgreSQL data (updating existing tables)..."
                  pg_restore --clean --if-exists --no-owner --no-privileges --dbname="$PGDATABASE" --host="$PGHOST" --username="$PGUSER" /storage/pg.dump

                  echo "Production PostgreSQL data sync completed successfully"
              envFrom:
                - secretRef:
                    name: {{ .Values.secrets.localSettings.ref }}
                - secretRef:
                    name: local-settings-secrets-{{ .Values.deployEnv }}
                    optional: true
                - configMapRef:
                    name: local-settings-{{ .Values.deployEnv }}
              resources:
                requests:
                  cpu: 500m
                  memory: 500Mi
                limits:
                  cpu: 750m
                  memory: "1Gi"
          restartPolicy: Never
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 2
{{- end }}
